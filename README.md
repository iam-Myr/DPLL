Αυτή η υλοποίηση του DPLL σε Java βασίζεται στον αλγόριθμο της Wikipedia:

Algorithm DPLL
  Input: A set of clauses Φ.
  Output: A Truth Value.

function DPLL(Φ)
   if Φ is a consistent set of literals
       then return true;
   if Φ contains an empty clause
       then return false;
   for every unit clause {l} in Φ
      Φ ← unit-propagate(l, Φ);
   for every literal l that occurs pure in Φ
      Φ ← pure-literal-assign(l, Φ);         <-- Το pure literal assign δεν υλοποιήθηκε.
   l ← choose-literal(Φ);
   return DPLL(Φ ∧ {l}) or DPLL(Φ ∧ {not(l)});

Το σύνολο Φ αναπαρίσταται από ένα ArrayList και κάθε πρόταση που περιέχεται στο σύνολο επίσης από ένα ArrayList. H συγκεκριμένη επιλογή έγινε ώστε να μπορούν να αφαιρούνται εύκολα τόσο λεκτικά μέσα από τις προτάσεις όσο και προτάσεις από το Φ.

Αυτή η διαδικασία της αφαίρεσης γίνεται με τη διάδοση περιορισμών (Unit Propagation or Boolean Constraint propagation), που στο πρόγραμμα αναλαμβάνει η συνάρτηση BCP. Η διαδικασία έχει ως εξής: 
    1) Βρίσκεται μια πρόταση με ένα μόνο λεκτικό (unit clause) *
    2) Κάθε πρόταση της Φ που περιέχει αυτό το λεκτικό διαγράφεται
    3) Σε κάθε πρόταση που υπάρχει το αντίθετο του λεκτικού (- l), αυτό διαγράφεται. 
    4) Επαναλαμβάνεται το Βήμα 1 μέχρι να μη βρεθεί unit clause.
(Με την αφαίρεση μπορεί να δημιουργηθούν καινούρια unit clauses)

Αφού δε μπορούν να διαγραφούν άλλου περιορισμοί, διαλέγεται ένα τυχαίο λεκτικό l που υπάρχει στο Φ και παίρνει αυθαίρετα τιμή, δηλαδή προστίθεται ως unit clause. Αυτό είναι το σημείο που δημιουργούνται οι δύο επιλογές για την τιμή του (True ή False), οι οποίες εξερευνούνται αναδρομικά. Φαίνεται πώς ο DPLL είναι ένας “βελτιωμένος” αλγόριθμος αναζήτησης κατά βάθος.

Η συνάρτηση DPLL καλείται ξανά, μια φορά με το καινούριο Φ που περιέχει το l και μια φορά με το Φ που περιέχει το -l και όλη η διαδικασία ξεκινάει από την αρχή με το νέο όρισμα. Η διαδικασία σταματάει σε δύο περιπτώσεις:
    1) Όταν στο Φ δεν έχουν μείνει περιορισμοί (το σύνολο είναι κενό). Αυτό είναι δυνατό γιατί κάθε φορά που χρησιμοποιείται ένα λεκτικο για διάδοση περιορισμών, διαγράφεται έπειτα από το Φ. Σε αυτή την περίπτωση υπάρχει λύση και η συνάρτηση επιστρέφει True.

    2) Όταν στο Φ υπάρχει ένας άδειος περιορισμός (χωρίς λεκτικά μέσα), έχει καταλήξει δηλαδή σε άτοπο. Σε αυτή την περίπτωση δεν υπάρχει λύση για αυτές τις τιμές, η συνάρτηση επιστρέφει False και πρέπει να κάνει backtrack στην προηγούμενη απόφαση που πήρε.

Αν δεν υπάρχει λύση για κανένα συνδυασμό τιμών τότε το πρόβλημα δεν έχει λύση. Επιστρέφεται μόνο True/False ανάλογα με την ύπαρξη λύσης, γιατί δεν ήταν απαραίτητο για τα ζητούμενα της εργασίας (σύγκριση χρόνου με άλλους αλγορίθμους).
